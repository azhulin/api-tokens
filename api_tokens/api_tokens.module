<?php


/**
 * Implements hook_filter_info().
 */
function api_tokens_filter_info() {
  $filters = array();

  $filters['api_tokens'] = array(
    'title' => t('Replace API tokens'),
    // @TODO: Informative description
    'description' => t('[Replace API tokens description]'),
    'process callback' => 'api_tokens_filter_tokens',
    'tips callback' => 'api_tokens_filter_tips',
    // Don't cache fitler result as text may contain dynamic tokens
    'cache' => FALSE,
  );

  return $filters;
}


/**
 * Filter tip callback for the API tokens input filter.
 */
function api_tokens_filter_tips($filter, $format, $long = FALSE) {
  if ($long) {
    // @TODO: Informative description
    $output = t('[API Tokens long description]');
  }
  else {
    // @TODO: Informative description
    $output = t('[API Tokens short description]');
  }

  return $output;
}


/**
 * Populates omitted token info.
 */
function api_tokens_populate_defaults($token, &$token_info, $module = 'api_tokens') {
  $token_info['module'] = $module;
  if (!isset($token_info['title'])) {
    $token_info['title'] = $token;
  }
  if (!isset($token_info['description'])) {
    $token_info['description'] = '';
  }
  if (!isset($token_info['handler'])) {
    $token_info['handler'] = $module . '_apitoken_' . str_replace(array('-', ':'), '_', $token);
  }
  if (!isset($token_info['cache'])) {
    $token_info['cache'] = DRUPAL_NO_CACHE;
  }
}


/**
 * Collects information on all the tokens in the system.
 */
function api_tokens_collect_tokens() {
  $tokens = &drupal_static(__FUNCTION__, FALSE);

  if (!$tokens) {
    require_once 'handlers/api_tokens.inc';
    // Collecting own tokens
    // Direct call to own pseudo-hook hook_api_tokens_info().
    $tokens = _api_tokens_api_tokens_info();
    foreach ($tokens as $token => &$token_info) {
      api_tokens_populate_defaults($token, $token_info);
    }

    // Collecting external tokens
    $modules = module_implements('api_tokens_info');
    foreach ($modules as $module) {
      $module_tokens = module_invoke($module, 'api_tokens_info');
      foreach ($module_tokens as $token => &$token_info) {
        api_tokens_populate_defaults($token, $token_info, $module);
      }
      $tokens = array_merge($tokens, $module_tokens);
    }
  }

  return $tokens;
}


/**
 * Returns the number of required parameters of the token process function.
 */
function api_tokens_param_info($token) {
  $tokens = &drupal_static('api_tokens_collect_tokens', FALSE);

  $reflection = new ReflectionFunction($tokens[$token]['handler']);
  $params = $reflection->getNumberOfRequiredParameters();
  $tokens[$token]['params'] = $params;

  return $params;
}


/**
 * API Tokens cache_set wrapper connected to static storage.
 */
function api_tokens_cache_set($cid, $data, $token_info) {
  $cache = &drupal_static('api_tokens_cache_get', FALSE);

  $expire = isset($token_info['cache_expire']) ? $token_info['cache_expire'] : CACHE_TEMPORARY;
  // If cache isn't set to CACHE_PERMANENT (0) or CACHE_TEMPORARY (-1), adding
  // request time to the expiration date in order to set correct expiration date.
  if (0 < $expire) {
    $expire += REQUEST_TIME;
  }

  // Storing into static
  $cache[$cid] = $data;

  cache_set($cid, $data, 'cache', $expire);
}


/**
 * API Tokens cache_get wrapper connected to static storage.
 */
function api_tokens_cache_get($cids) {
  $cache = &drupal_static(__FUNCTION__, FALSE);

  $data = array();
  // Checking static storage
  foreach ($cids as $i => $cid) {
    if (isset($cache[$cid])) {
      $data[$i] = $cache[$cid];
      unset($cids[$i]);
    }
  }

  // If not all cids are found in static storage, cheching DB cache
  if (count($cids)) {
    // Creating a reference to $cids and passing it to cache_get as $cids will be overriden after call.
    $cids_ref = $cids;
    $cache_ext = cache_get_multiple($cids_ref);

    foreach ($cids as $i => $cid) {
      // Checking if DB cache exists and its expiration date
      if (isset($cache_ext[$cid]) && (0 >= $cache_ext[$cid]->expire
          || 0 < $cache_ext[$cid]->expire && REQUEST_TIME <= $cache_ext[$cid]->expire)) {
        // Storing to static
        $cache[$cid] = $cache_ext[$cid]->data;
        $data[$i] = $cache[$cid];
      }
      else {
        $data[$i] = FALSE;
      }
    }
  }

  return $data;
}


/**
 * Filter process callback for the API Tokens input filter.
 */
function api_tokens_filter_tokens($text, $filter, $format, $langcode, $cache, $cache_id) {
  global $user;

  // Finding tokens entries to process
  $token_count = preg_match_all('/\[\s*api\s*:\s*([:0-9a-z_-]+)\s*(\[.*?\])?\s*\\/\s*]/i', $text, $matches);
  // Some tokens were found
  if ($token_count) {
    $replacements = $matches[0];
    $funarg = $matches[1];
    $params = $matches[2];

    // Receiving all registered tokens
    $tokens = api_tokens_collect_tokens();
    // Array of rendered tokens
    $rendered = array();
    // Array of token cache
    $cids = array();

    // Loop through all the tokens
    for ($i = 0; $i < $token_count; ++$i) {
      $funarg[$i] = strtolower($funarg[$i]);

      // Checking if token is registered
      if (array_key_exists($funarg[$i], $tokens)) {
        $rendered[$i] = FALSE;
        $token_info = $tokens[$funarg[$i]];
        // Parsing token parameters
        $params[$i] = $params[$i] ? drupal_json_decode($params[$i]) : NULL;

        // Token is cacheable
        if (DRUPAL_NO_CACHE != $token_info['cache']) {
          // Building token cache ID
          $hash = array($params[$i]);
          // Cache ID prefix
          $prefix = 'apitoken:' . $funarg[$i] . ':';

          // Populating hash parts depending on included caching types
          for ($shift = 0; 3 > $shift; ++$shift) {
            $flag = $token_info['cache'] >> $shift & 1;
            // Cache flag is enabled
            if ($flag) {
              switch ($shift) {

                case 0:
                  // DRUPAL_CACHE_PER_ROLE
                  $hash[1] = implode(',', $user->roles);
                  break;

                case 1:
                  // DRUPAL_CACHE_PER_USER
                  $hash[2] = $user->uid;
                  break;

                case 2:
                  // DRUPAL_CACHE_PER_PAGE
                  $hash[3] = $_GET['q'];
                  break;

                // No need in case for DRUPAL_CACHE_GLOBAL
              }
            }
          }
          $cids[$i] = $prefix . md5(serialize($hash));
        }
      }
      // Cut out unregistered tokens
      else {
        $rendered[$i] = '';
      }
    }

    // There were cacheable tokens
    if ($cids) {
      // We have collected all cids, so we can grab all necessary at once
      $cache = api_tokens_cache_get($cids);
      foreach ($cache as $i => $data) {
        $rendered[$i] = $data;
      }
    }

    // Processing tokens with missing cache
    foreach ($rendered as $i => $was_rendered) {
      if (FALSE === $was_rendered) {
        $token_info = $tokens[$funarg[$i]];

        // Checking for inc file where token process function may live
        // We skiping tokens with no module key. It is own tokens which have been already included.
        if (isset($token_info['inc']) && isset($token_info['module'])) {
          // Trying to include
          $included = module_load_include('inc', $token_info['module'], $token_info['inc']);
          // Skipping a token on fail
          if (!$included) {
            continue;
          }
        }

        // Checking process function existence
        if (function_exists($token_info['handler'])) {
          // Receiving number of required parameters
          $param_count = isset($token_info['params']) ? $token_info['params'] : api_tokens_param_info($funarg[$i]);
          // We have enough parameters
          if ($param_count <= count($params[$i])) {
            // Calling token process function
            $rendered[$i] = call_user_func_array($token_info['handler'], $params[$i]);
            // Caching handler result, if token is cacheable
            if (DRUPAL_NO_CACHE != $token_info['cache']) {
              api_tokens_cache_set($cids[$i], $rendered[$i], $token_info);
            }
          }
        }
      }
    }

    // Performing replacements at once to avoid recursing
    $text = str_replace($replacements, $rendered, $text);
  }

  return $text;
}
